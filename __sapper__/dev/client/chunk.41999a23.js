import { a as SvelteComponentDev, b as init, c as safe_not_equal, h as element, i as text, g as space, k as claim_element, l as children, j as claim_text, m as detach, n as add_location, C as listen, o as insert, p as append, t as mount_component, q as set_data } from './chunk.989912da.js';
import { a as ReceiveMessage } from './chunk.75c83501.js';

/* src/components/SampleData.svelte generated by Svelte v3.4.2 */

const file = "src/components/SampleData.svelte";

// (6:38) 
function create_if_block_1(ctx) {
	var i;

	return {
		c: function create() {
			i = element("i");
			this.h();
		},

		l: function claim(nodes) {
			i = claim_element(nodes, "I", { class: true }, false);
			var i_nodes = children(i);

			i_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			i.className = "fa fa-times";
			add_location(i, file, 6, 4, 311);
		},

		m: function mount(target, anchor) {
			insert(target, i, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(i);
			}
		}
	};
}

// (4:4) {#if _result === 'Valid'}
function create_if_block(ctx) {
	var i;

	return {
		c: function create() {
			i = element("i");
			this.h();
		},

		l: function claim(nodes) {
			i = claim_element(nodes, "I", { class: true }, false);
			var i_nodes = children(i);

			i_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			i.className = "fa fa-check";
			add_location(i, file, 4, 4, 240);
		},

		m: function mount(target, anchor) {
			insert(target, i, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(i);
			}
		}
	};
}

// (2:0) <ReceiveMessage channel="DEMO_VALIDATE_RESULT" on:received={receive} sender={sender}>
function create_default_slot(ctx) {
	var td;

	function select_block_type(ctx) {
		if (ctx._result === 'Valid') return create_if_block;
		if ((ctx._result === 'Invalid')) return create_if_block_1;
	}

	var current_block_type = select_block_type(ctx);
	var if_block = current_block_type && current_block_type(ctx);

	return {
		c: function create() {
			td = element("td");
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			td = claim_element(nodes, "TD", { class: true }, false);
			var td_nodes = children(td);

			if (if_block) if_block.l(td_nodes);
			td_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			td.className = "pv2 ph3";
			add_location(td, file, 2, 0, 185);
		},

		m: function mount(target, anchor) {
			insert(target, td, anchor);
			if (if_block) if_block.m(td, null);
		},

		p: function update(changed, ctx) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);
				if (if_block) {
					if_block.c();
					if_block.m(td, null);
				}
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(td);
			}

			if (if_block) if_block.d();
		}
	};
}

function create_fragment(ctx) {
	var td, span, t0_value = ctx.renderSample(ctx.sample), t0, t1, current, dispose;

	var receivemessage = new ReceiveMessage({
		props: {
		channel: "DEMO_VALIDATE_RESULT",
		sender: ctx.sender,
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	},
		$$inline: true
	});
	receivemessage.$on("received", ctx.receive);

	return {
		c: function create() {
			td = element("td");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			receivemessage.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			td = claim_element(nodes, "TD", { class: true }, false);
			var td_nodes = children(td);

			span = claim_element(td_nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t0 = claim_text(span_nodes, t0_value);
			span_nodes.forEach(detach);
			td_nodes.forEach(detach);
			t1 = claim_text(nodes, "\n");
			receivemessage.$$.fragment.l(nodes);
			this.h();
		},

		h: function hydrate() {
			span.className = "link pointer";
			add_location(span, file, 0, 20, 20);
			td.className = "pv2 ph3";
			add_location(td, file, 0, 0, 0);
			dispose = listen(span, "click", ctx.click);
		},

		m: function mount(target, anchor) {
			insert(target, td, anchor);
			append(td, span);
			append(span, t0);
			insert(target, t1, anchor);
			mount_component(receivemessage, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.renderSample || changed.sample) && t0_value !== (t0_value = ctx.renderSample(ctx.sample))) {
				set_data(t0, t0_value);
			}

			var receivemessage_changes = {};
			if (changed.sender) receivemessage_changes.sender = ctx.sender;
			if (changed.$$scope || changed._result) receivemessage_changes.$$scope = { changed, ctx };
			receivemessage.$set(receivemessage_changes);
		},

		i: function intro(local) {
			if (current) return;
			receivemessage.$$.fragment.i(local);

			current = true;
		},

		o: function outro(local) {
			receivemessage.$$.fragment.o(local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(td);
				detach(t1);
			}

			receivemessage.$destroy(detaching);

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let _result = '';

// Props
let { sender = '', sample = '', renderSample = (sample) => sample } = $$props;

const click = () => {
    const frame = document.querySelector(`iframe[src^="${sender}"]`);
    if (frame) {
        // Send sample to demo frame
        frame.contentWindow.postMessage({
            channel: 'SAMPLE_FIELD_VALUE',
            sender: sender,
            data: sample
        }, window.location.origin);
    }
};

const receive = (e) => {
    const data = e.detail.data;
    if (JSON.stringify(data.input) === JSON.stringify(sample)) {
        $$invalidate('_result', _result = data.output);
    }
};

	$$self.$set = $$props => {
		if ('sender' in $$props) $$invalidate('sender', sender = $$props.sender);
		if ('sample' in $$props) $$invalidate('sample', sample = $$props.sample);
		if ('renderSample' in $$props) $$invalidate('renderSample', renderSample = $$props.renderSample);
	};

	return {
		_result,
		sender,
		sample,
		renderSample,
		click,
		receive
	};
}

class SampleData extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["sender", "sample", "renderSample"]);
	}

	get sender() {
		throw new Error("<SampleData>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sender(value) {
		throw new Error("<SampleData>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sample() {
		throw new Error("<SampleData>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sample(value) {
		throw new Error("<SampleData>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderSample() {
		throw new Error("<SampleData>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderSample(value) {
		throw new Error("<SampleData>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { SampleData as a };

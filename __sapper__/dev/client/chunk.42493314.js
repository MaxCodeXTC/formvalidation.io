import { a as SvelteComponentDev, b as init, c as safe_not_equal, h as element, k as claim_element, l as children, m as detach, G as toggle_class, n as add_location, C as listen, o as insert, p as append, r as noop, H as createEventDispatcher, t as mount_component, d as create_slot, g as space, j as claim_text, D as add_binding_callback, x as group_outros, z as check_outros, e as get_slot_changes, f as get_slot_context, I as destroy_each, B as onMount, y as on_outro } from './chunk.989912da.js';

/* src/components/Tab.svelte generated by Svelte v3.4.2 */

const file = "src/components/Tab.svelte";

function create_fragment(ctx) {
	var li, button, li_class_value, dispose;

	return {
		c: function create() {
			li = element("li");
			button = element("button");
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			button = claim_element(li_nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			button_nodes.forEach(detach);
			li_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			button.className = "tab-button pointer dark-gray ph3 pv2 dib bn bg-transparent svelte-6wd5km";
			toggle_class(button, "b", ctx.isSelected);
			add_location(button, file, 7, 4, 132);
			li.className = li_class_value = "dib bt bw2 " + (ctx.isSelected ? 'b--blue ' : 'b--transparent') + " svelte-6wd5km";
			add_location(li, file, 6, 0, 59);
			dispose = listen(button, "click", ctx.select);
		},

		m: function mount(target, anchor) {
			insert(target, li, anchor);
			append(li, button);
			button.innerHTML = ctx.title;
		},

		p: function update(changed, ctx) {
			if (changed.title) {
				button.innerHTML = ctx.title;
			}

			if (changed.isSelected) {
				toggle_class(button, "b", ctx.isSelected);
			}

			if ((changed.isSelected) && li_class_value !== (li_class_value = "dib bt bw2 " + (ctx.isSelected ? 'b--blue ' : 'b--transparent') + " svelte-6wd5km")) {
				li.className = li_class_value;
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(li);
			}

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	// Public props
let { isSelected = false, title = '' } = $$props;

const dispatch = createEventDispatcher();

const select = () => {
    dispatch('active', {
        title: title,
    });
};

	$$self.$set = $$props => {
		if ('isSelected' in $$props) $$invalidate('isSelected', isSelected = $$props.isSelected);
		if ('title' in $$props) $$invalidate('title', title = $$props.title);
	};

	return { isSelected, title, select };
}

class Tab extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["isSelected", "title"]);
	}

	get isSelected() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isSelected(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Tabs.svelte generated by Svelte v3.4.2 */

const file$1 = "src/components/Tabs.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.title = list[i];
	child_ctx.i = i;
	return child_ctx;
}

// (2:4) {#each titles as title, i}
function create_each_block(ctx) {
	var current;

	var tab = new Tab({
		props: {
		title: ctx.title,
		isSelected: ctx.i === ctx.activeIndex
	},
		$$inline: true
	});
	tab.$on("active", ctx.active(ctx.i));

	return {
		c: function create() {
			tab.$$.fragment.c();
		},

		l: function claim(nodes) {
			tab.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(tab, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var tab_changes = {};
			if (changed.titles) tab_changes.title = ctx.title;
			if (changed.activeIndex) tab_changes.isSelected = ctx.i === ctx.activeIndex;
			tab.$set(tab_changes);
		},

		i: function intro(local) {
			if (current) return;
			tab.$$.fragment.i(local);

			current = true;
		},

		o: function outro(local) {
			tab.$$.fragment.o(local);
			current = false;
		},

		d: function destroy(detaching) {
			tab.$destroy(detaching);
		}
	};
}

function create_fragment$1(ctx) {
	var ul, t, div, current;

	var each_value = ctx.titles;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function outro_block(i, detaching, local) {
		if (each_blocks[i]) {
			if (detaching) {
				on_outro(() => {
					each_blocks[i].d(detaching);
					each_blocks[i] = null;
				});
			}

			each_blocks[i].o(local);
		}
	}

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c: function create() {
			ul = element("ul");

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			div = element("div");

			if (default_slot) default_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach);
			t = claim_text(nodes, "\n");

			div = claim_element(nodes, "DIV", {}, false);
			var div_nodes = children(div);

			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			ul.className = "list pl0 mb0 list pa0 ma0 flex items-center justify-center";
			add_location(ul, file$1, 0, 0, 0);

			add_location(div, file$1, 5, 0, 200);
		},

		m: function mount(target, anchor) {
			insert(target, ul, anchor);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert(target, t, anchor);
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			add_binding_callback(() => ctx.div_binding(div, null));
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.titles || changed.activeIndex || changed.active) {
				each_value = ctx.titles;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						each_blocks[i].i(1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].i(1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();
				for (; i < each_blocks.length; i += 1) outro_block(i, 1, 1);
				check_outros();
			}

			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}

			if (changed.items) {
				ctx.div_binding(null, div);
				ctx.div_binding(div, null);
			}
		},

		i: function intro(local) {
			if (current) return;
			for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

			if (default_slot && default_slot.i) default_slot.i(local);
			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) outro_block(i, 0);

			if (default_slot && default_slot.o) default_slot.o(local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(ul);
			}

			destroy_each(each_blocks, detaching);

			if (detaching) {
				detach(t);
				detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			ctx.div_binding(null, div);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	

const dispatch = createEventDispatcher();

let contentEle;
let tabs;
let currentTab;
let activeIndex = 0;

// Public props
let { titles = [] } = $$props;

const active = index => e => {
    $$invalidate('activeIndex', activeIndex = index);
    currentTab.classList.add('dn');
    $$invalidate('currentTab', currentTab = tabs[index]);
    currentTab.classList.remove('dn');

    dispatch('activateTab', {
        index,
    });
};

onMount(() => {
    $$invalidate('tabs', tabs = contentEle.children);
    const numTabs = tabs.length;

    // Hide all child nodes except the first one
    for (let i = 0; i < numTabs; i++) {
        (tabs[i].classList) ? tabs[i].classList.add('dn') : tabs[i].className = 'dn'; $$invalidate('tabs', tabs);
    }

    $$invalidate('currentTab', currentTab = tabs[0]);
    currentTab.classList.remove('dn');
});

	let { $$slots = {}, $$scope } = $$props;

	function div_binding($$node, check) {
		contentEle = $$node;
		$$invalidate('contentEle', contentEle);
	}

	$$self.$set = $$props => {
		if ('titles' in $$props) $$invalidate('titles', titles = $$props.titles);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return {
		contentEle,
		activeIndex,
		titles,
		active,
		div_binding,
		$$slots,
		$$scope
	};
}

class Tabs extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["titles"]);
	}

	get titles() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set titles(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Tabs as a };

import { a as SvelteComponentDev, b as init, c as safe_not_equal, h as element, g as space, i as text, k as claim_element, l as children, j as claim_text, m as detach, n as add_location, o as insert, t as mount_component, p as append, w as empty, x as group_outros, z as check_outros, I as destroy_each, y as on_outro, r as noop } from './chunk.989912da.js';
import { a as Cards, b as Card } from './chunk.77ca656e.js';
import { a as Heading } from './chunk.aa7fcff5.js';
import { b as AllValidators, c as camelCaseToDash } from './chunk.2ddcebe2.js';

/* src/components/RelatedValidators.svelte generated by Svelte v3.4.2 */

const file = "src/components/RelatedValidators.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.v = list[i];
	return child_ctx;
}

// (2:4) <Heading>
function create_default_slot_2(ctx) {
	var t;

	return {
		c: function create() {
			t = text("Related validators");
		},

		l: function claim(nodes) {
			t = claim_text(nodes, "Related validators");
		},

		m: function mount(target, anchor) {
			insert(target, t, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (7:8) <Card target="/guide/validators/{camelCaseToDash(v.name)}" title="{v.name}">
function create_default_slot_1(ctx) {
	var t_value = ctx.v.description, t;

	return {
		c: function create() {
			t = text(t_value);
		},

		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},

		m: function mount(target, anchor) {
			insert(target, t, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (6:4) {#each _relatedValidators as v}
function create_each_block(ctx) {
	var current;

	var card = new Card({
		props: {
		target: "/guide/validators/" + camelCaseToDash(ctx.v.name),
		title: ctx.v.name,
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	return {
		c: function create() {
			card.$$.fragment.c();
		},

		l: function claim(nodes) {
			card.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var card_changes = {};
			if (changed.camelCaseToDash || changed._relatedValidators) card_changes.target = "/guide/validators/" + camelCaseToDash(ctx.v.name);
			if (changed._relatedValidators) card_changes.title = ctx.v.name;
			if (changed.$$scope) card_changes.$$scope = { changed, ctx };
			card.$set(card_changes);
		},

		i: function intro(local) {
			if (current) return;
			card.$$.fragment.i(local);

			current = true;
		},

		o: function outro(local) {
			card.$$.fragment.o(local);
			current = false;
		},

		d: function destroy(detaching) {
			card.$destroy(detaching);
		}
	};
}

// (5:4) <Cards>
function create_default_slot(ctx) {
	var each_1_anchor, current;

	var each_value = ctx._relatedValidators;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function outro_block(i, detaching, local) {
		if (each_blocks[i]) {
			if (detaching) {
				on_outro(() => {
					each_blocks[i].d(detaching);
					each_blocks[i] = null;
				});
			}

			each_blocks[i].o(local);
		}
	}

	return {
		c: function create() {
			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},

		l: function claim(nodes) {
			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},

		m: function mount(target, anchor) {
			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.camelCaseToDash || changed._relatedValidators) {
				each_value = ctx._relatedValidators;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						each_blocks[i].i(1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].i(1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();
				for (; i < each_blocks.length; i += 1) outro_block(i, 1, 1);
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) outro_block(i, 0);

			current = false;
		},

		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);

			if (detaching) {
				detach(each_1_anchor);
			}
		}
	};
}

function create_fragment(ctx) {
	var section, t0, p, t1, t2, current;

	var heading = new Heading({
		props: {
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var cards = new Cards({
		props: {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	return {
		c: function create() {
			section = element("section");
			heading.$$.fragment.c();
			t0 = space();
			p = element("p");
			t1 = text("The following validators might be useful to you.");
			t2 = space();
			cards.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true }, false);
			var section_nodes = children(section);

			heading.$$.fragment.l(section_nodes);
			t0 = claim_text(section_nodes, "\n    ");

			p = claim_element(section_nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			t1 = claim_text(p_nodes, "The following validators might be useful to you.");
			p_nodes.forEach(detach);
			t2 = claim_text(section_nodes, "\n\n    ");
			cards.$$.fragment.l(section_nodes);
			section_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			p.className = "lh-copy";
			add_location(p, file, 2, 4, 68);
			section.className = "mv5";
			add_location(section, file, 0, 0, 0);
		},

		m: function mount(target, anchor) {
			insert(target, section, anchor);
			mount_component(heading, section, null);
			append(section, t0);
			append(section, p);
			append(p, t1);
			append(section, t2);
			mount_component(cards, section, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var heading_changes = {};
			if (changed.$$scope) heading_changes.$$scope = { changed, ctx };
			heading.$set(heading_changes);

			var cards_changes = {};
			if (changed.$$scope) cards_changes.$$scope = { changed, ctx };
			cards.$set(cards_changes);
		},

		i: function intro(local) {
			if (current) return;
			heading.$$.fragment.i(local);

			cards.$$.fragment.i(local);

			current = true;
		},

		o: function outro(local) {
			heading.$$.fragment.o(local);
			cards.$$.fragment.o(local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(section);
			}

			heading.$destroy();

			cards.$destroy();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	

let { validators } = $$props;
const _relatedValidators = AllValidators.filter((v) => {
    return validators.indexOf(v.name) >= 0;   
});

	$$self.$set = $$props => {
		if ('validators' in $$props) $$invalidate('validators', validators = $$props.validators);
	};

	return { validators, _relatedValidators };
}

class RelatedValidators extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["validators"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.validators === undefined && !('validators' in props)) {
			console.warn("<RelatedValidators> was created without expected prop 'validators'");
		}
	}

	get validators() {
		throw new Error("<RelatedValidators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validators(value) {
		throw new Error("<RelatedValidators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { RelatedValidators as a };
